{"meta":{"title":"Ludwig's blog","subtitle":null,"description":null,"author":"HerrLudwig","url":"https://herrludwig.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T06:57:02.000Z","updated":"2019-08-06T06:58:51.157Z","comments":true,"path":"categories/index.html","permalink":"https://herrludwig.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-06T06:59:16.000Z","updated":"2019-08-06T07:05:11.406Z","comments":true,"path":"tags/index.html","permalink":"https://herrludwig.github.io/tags/index.html","excerpt":"","text":""},{"title":"whoami","date":"2019-08-06T07:04:22.000Z","updated":"2019-08-09T00:19:27.365Z","comments":true,"path":"whoami/index.html","permalink":"https://herrludwig.github.io/whoami/index.html","excerpt":"","text":"博主简介华中科技大学 / 软件工程 / 硕士研究生 吉他手 / 胶佬 / Sneaker / 摄影爱好者 感谢您浏览我的博客，我是Ludwg，目前正在努力学习前端技术。如果我的博客能有一点点帮到您，那真是太好了！"}],"posts":[{"title":"Koa中间件","slug":"8","date":"2018-11-12T08:41:46.000Z","updated":"2019-08-21T03:05:44.967Z","comments":true,"path":"2018/11/12/8/","link":"","permalink":"https://herrludwig.github.io/2018/11/12/8/","excerpt":"","text":"一、什么是 Koa 中间件通俗的讲中间件就是在匹配路由之前或者匹配路由完成后做的一系列的操作，我们就可以把它叫做中间件。express 的中间件 (Middleware) 是一个函数，它可以访问请求对象 (request object / req) 与响应对象 (response object / res)。web 应用中处理“请求-响应循环”流程的中间件，一般被命名为 next 变量。Koa 的中间件和 express 有点类似。中间件的功能包括：1、执行任何代码。2、修改请求和响应对象。3、终结请求-响应循环。4、调用堆栈中的下一个中间件。中间件的标志是next，如果在 get、post 回调函数中没有 next 参数，那么匹配上第一个路由之后就不会往下匹配了。如果想继续往下匹配的话就需要写 next() 二、Koa 中可使用的中间件：主要分为四种：应用级中间件、路由级中间件、错误处理中间件、第三方中间件 应用级中间件 123456//匹配任何路由之前打印日期app.use(async (ctx,next)=&gt;&#123; //不写next路由就会终止 console.log(new Date()); await next(); //当前路由匹配完成以后继续向下匹配&#125;) 路由级中间件 12345678910// 匹配到news路由以后继续向下匹配router.get('/news',async (ctx,next)=&gt;&#123; //实现先打印后访问 console.log('这是一个新闻'); await next();&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body='这是一个新闻';&#125;) 错误处理中间件 12345678910111213//输入路由app.use(async (ctx,next)=&gt;&#123; console.log('这是错误处理中间件'); //先打印这个 await next(); if(ctx.status==404)&#123; //如果页面找不到 ctx.status = 404; ctx.body=\"404 页面\" &#125;else&#123; console.log(ctx.url); //如果页面找得到，先执行页面，最后打印其 url &#125;&#125;) 第三方中间件 12345678const static = require('koa-static');const staticPath = './static';app.use(static( path.join( __dirname, staticPath)))const bodyParser = require('koa-bodyparser');app.use(bodyParser()); 三、Koa 中间件的执行顺序Koa 的中间件和 Express 不同，Koa 选择了洋葱模型。 1234567891011121314151617181920212223//输入www.域名.com/newsapp.use(async (ctx,next)=&gt;&#123; console.log('1、第一个中间件'); await next(); console.log('5、匹配路由完成以后又会返回来执行中间件');&#125;)app.use(async (ctx,next)=&gt;&#123; console.log('2、第二个中间件'); await next(); console.log('4、匹配路由完成以后又会返回来执行中间件');&#125;)router.get('/news',async (ctx)=&gt;&#123; console.log('3、匹配到了news路由'); ctx.body='这是一个新闻';&#125;)//执行顺序12345","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"Koa路由、get传值、动态路由","slug":"7","date":"2018-11-09T05:02:25.000Z","updated":"2019-08-21T02:25:58.011Z","comments":true,"path":"2018/11/09/7/","link":"","permalink":"https://herrludwig.github.io/2018/11/09/7/","excerpt":"","text":"一、Koa路由路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，应用涉及到如何响应客户端对某个网站节点的访问。通俗的讲：路由就是根据不同的 URL 地址，加载不同的页面，实现不同的功能。Koa 中的路由和 Express 有所不同，在 Express 中直接引入 Express 就可以配置路由，但是在 Koa 中我们需要安装对应的 koa-router 路由模块来实现。 1npm install --save koa-router 1234567891011121314151617const Koa = require('koa');const router = require('koa-router')(); //注意引入的方式const app = new Koa()router.get('/',async (ctx)=&gt;&#123; //context上下文，包含了req与res ctx.body=\"首页\" //相当于原生里面的res.writeHead() 和 res.end()&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body=\"新闻\"&#125;);app.use(router.routes()) //启动路由app.use(router.allowedMethods()) //在所有路由中间件中最后调用app.listen(3000) 二、Koa 路由 get 传值在 Koa 中 GET 传值通过 request 接收，但是接收的方法有两种：query 和 querystring。1、query：返回的是格式化好的参数对象2、querystring：返回的是请求字符串 123456789router.get('/newscontent',(ctx,next)=&gt;&#123; //从ctx中读取get传值 console.log(ctx.query) //&#123; aid: '123' &#125;，获取的是对象。用的最多的方式 console.log(ctx.querystring) //aid=123&amp;name=zhangsan，获取的是一个字符串 console.log(ctx.url) //获取url地址 ctx.body=\"新闻详情\";&#125;); 三、Koa 动态路由动态路由传值的获取方法：http://域名/newscontent/xxxx 123456router.get('/newscontent/:aid',async (ctx)=&gt;&#123; console.log(ctx.params); //&#123; aid: 'xxxx' &#125; ctx.body=\"新闻详情\";&#125;) 动态路由里面可以传入多个值 /newscontent/:aid/:cid","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"Koa框架介绍、环境搭建以及异步的使用","slug":"6","date":"2018-11-05T09:52:09.000Z","updated":"2019-08-21T02:26:43.322Z","comments":true,"path":"2018/11/05/6/","link":"","permalink":"https://herrludwig.github.io/2018/11/05/6/","excerpt":"","text":"一、Koa框架介绍Node.js 是一个异步的世界，官方 API 支持的都是 callback 形式的异步编程模型。这会带来许多问题，例如：1、callback 嵌套问题；2、异步函数中可能同步调用 callback 返回数据，带来不一致性。为了解决以上问题，Koa 出现了。Koa 是一个由 Express 幕后的原班人马打造的 web 框架， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过使用 Es7 中的 async 和 await，Koa 帮你丢弃回调函数，并有力地提升错误处理效率。 Koa 并没有捆绑任何中间件，而是提供了一个轻量优雅的函数库，使得编写服务端应用变得得心应手。Koa 的开发思路和 express 差不多，最大的特点就是可以避免异步嵌套。Koa基于最新的Es6、Es7语法，运行速度比Express更快。目前阿里就在使用 Koa 框架，并在 Koa 基础上面做了一些扩展和封装开发了一个开源框架 Egg.js。 二、Koa框架的安装使用1、安装 Node.js 8.x 以上的版本Koa要求 Node.js 的版本高于 V7.6。因为 Node.js 7.6 版本开始完全支持 async/await，所以才能完全支持我们的 Koa2。2、安装使用：首先打开项目文件夹 1npm init 生成 package.json 来管理项目的各种模块 1npm install --save koa / cnpm install --save koa –save 表示自动修改 package.json 文件，自动添加依赖项。 123456789const koa=require('koa');const app=new koa();app.use(async(ctx)=&gt;&#123; //配置中间件 （可以先当做路由） ctx.body='hello koa'&#125;)app.listen(3000); 三、Koa常用的ES6语法1、let和const（都是块作用域）2、模板字符串 123let name='Sam'let age=20console.log(`$&#123;name&#125;的年龄是$&#123;age&#125;`) 3、属性和方法的简写 1234567891011let name='Sam'var app=&#123; name, run()&#123; console.log(`$&#123;this.name&#125;在跑步`) &#125;&#125;app.run() 4、箭头函数：this 指向上下文，function() 变成 ()=&gt;5、Promise 123456789101112131415function getData(resolve,reject)&#123; setTimeout(()=&gt;&#123; var name='Sam' resolve(name) &#125;,1000);&#125;var p=new Promise(getData)p.then((data)=&gt;&#123; console.log(data)&#125;) 四、Koa异步处理Async、Await和Promise的使用async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。简单理解：async 是让方法变成异步。await 是等待异步方法执行完成。详细说明： 1234567async function testAsync()&#123; return 'Hello async';&#125;const result = testAsync();console.log(result); async 是让方法变成异步，在终端里用 node 执行这段代码，你会发现输出了 1Promise &#123; 'Hello async' &#125; 即返回的是 Promise。 await 在等待 async 方法执行完毕，其实 await 等待的只是一个表达式，这个表达式在官方文档里说的是 Promise 对象，但是它也可以接受普通值。注意：await 必须在 async 方法中才可以使用，因为 await 访问本身会造成程序堵塞，所以必须在异步方法中才可以使用。 12345678910111213141516async function getData()&#123; console.log(2)&#125;async function test()&#123; console.log(1) var d=await getData() console.log(d) console.log(3)&#125;test()//运行结果是1 2 3 await的阻塞功能把异步改成了同步 async/await 同时使用：async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。 1234567891011121314151617function findData() &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; var name='Same' resolve(name) &#125;,1000) &#125;) //定义一个返回promise的方法&#125;async function test() &#123; const v = await findData() console.log(v)&#125;test()","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"aggregate聚合管道","slug":"5","date":"2018-09-16T10:36:27.000Z","updated":"2019-08-18T15:23:43.146Z","comments":true,"path":"2018/09/16/5/","link":"","permalink":"https://herrludwig.github.io/2018/09/16/5/","excerpt":"","text":"一、管道操作符与表达式管道操作符作为“键”，所对应的“值”叫做管道表达式。例如 1&#123;$match:&#123;status:\"A\"&#125;&#125; $match 称为管道操作符，而 status:”A” 称为管道表达式，是管道操作符的操作数(Operand)。每个管道表达式是一个文档结构，它是由字段名、字段值、和一些表达式操作符组成的。 二、在MongoDB中使用聚合管道使用聚合管道可以对集合中的文档进行变换和组合。在实际项目中聚合管道多用于表关联查询和数据的统计。在 MongoDB 中使用 db.集合名.aggregate([{ },…]) 的方法来构建和使用聚合管道。下图为官网给出的实例： 三、mongoose aggregate多表关联查询mongoose 里聚合管道的语法与 MongoDB 中相似。以淘宝订单与订单详情为例，为了将订单表与订单物品关联起来，先在 model 里封装好 order.js 与 order_item.js，然后只将 order model 引入主程序 123456789101112131415161718192021222324var OrderModel=require('./model/order.js');OrderModel.aggregate([&#123; $lookup: &#123; from: \"order_item\", localField: \"order_id\", foreignField: \"order_id\", //通过order_id关联起来 as: \"items\" &#125; &#125;, &#123; $match: &#123; \"all_price\": &#123; $gte: 90 &#125; &#125; //筛选总价大于90的 &#125;], function (err, docs) &#123; if (err) &#123; console.log(err) return; &#125; console.log(JSON.stringify(docs))&#125;)//然后 node .\\app.js 终端运行 通过以上示例我们实现了两个表之间的关联查询，由于管道并没有数量限制，因此我们可以通过同样的方式实现多个表之间的关联查询。如下图所示，如果我们想查询文章信息，同时显示文章的分类以及作者信息，就需要使用聚合管道将这三个表关联起来。 12345678910111213141516171819202122232425var ArticleModel=require('./model/article.js'); //查哪个表就引入哪个表ArticleModel.aggregate([&#123; $lookup: &#123; from: \"articlecate\", localField: \"cid\", //分类表的_id对应文章表的cid foreignField: \"_id\", as: \"cate\" &#125; &#125;, &#123; $lookup: &#123; from: \"user\", localField: \"author_id\", //作者表的_id对应文章表的author_id foreignField: \"_id\", as: \"user\" &#125; &#125;], function (err, docs) &#123; console.log(JSON.stringify(docs));&#125;)","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose数据校验","slug":"4","date":"2018-09-14T12:16:15.000Z","updated":"2019-08-18T15:21:54.780Z","comments":true,"path":"2018/09/14/4/","link":"","permalink":"https://herrludwig.github.io/2018/09/14/4/","excerpt":"","text":"一、校验参数1、required: 表示这个数据必须传入2、max: 用于 Number 类型数据，最大值3、min: 用于 Number 类型数据，最小值4、enum：枚举类型，要求数据必须满足枚举值 enum: [‘0’, ‘1’, ‘2’]，用于 string5、match：增加的数据必须符合 match 正则表达式，用于 string6、maxlength：最大长度，用于 string7、minlength：最小长度例如在定义 Schema 时加入校验参数 12345678910111213141516171819202122232425262728var UserSchema=mongoose.Schema(&#123; name:&#123; type:String, //指定类型 trim:true, //去空格 required:true //name必须传入 &#125;, sn:&#123; type:String, index:true, //索引. match:/^sn(.*)/i, //必须以sn为开头，忽略大小写 minlength:10 &#125;, age:&#123; type:Number, min:0, //用在number类型上面 max:150 &#125;, status:&#123; type:String, default:'success', //默认值 enum:['success','error'] //status的值必须在对应的数组里面，注意枚举是用于String &#125;&#125;) 二、自定义验证器与自定义修饰符 set 相似，我们可以使用 validate 来自定义验证器。如果通过验证就返回 true，没有通过则返回 false。在上个例子中 sn 可以改成如下自定义验证器： 123456789sn:&#123; type:String, index:true, //索引. match:/^sn(.*)/i, //必须以sn为开头，忽略大小写 validate: function(sn) &#123; return sn.length &gt;= 10; //sn长度大于等于10 &#125; &#125;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose索引","slug":"3","date":"2018-09-11T13:18:02.000Z","updated":"2019-08-18T15:19:10.914Z","comments":true,"path":"2018/09/11/3/","link":"","permalink":"https://herrludwig.github.io/2018/09/11/3/","excerpt":"","text":"一、设置索引索引是对数据库表中一列或多列的值进行排序的一种结构，可以让我们查询数据库变得更快。MongoDB 的索引几乎与传统的关系型数据库一模一样，在 mongoose 中可以在定义 Schema 的时候创建索引。 12345678910111213var DeviceSchema = new mongoose.Schema(&#123; sn: &#123; type: Number, unique: true // 唯一索引 &#125;, name: &#123; type: String, index: true // 普通索引 &#125;&#125;) 二、CURDCURD代表创建（Create）、更新（Update）、读取（Retrive）和删除（Delete）操作，mongoose 中内置的 CURD 有如下这些：https://mongoosejs.com/docs/queries.html1、Model.deleteMany()2、Model.deleteOne()3、Model.find()4、Model.findById()5、Model.findByIdAndDelete()6、Model.findByIdAndRemove()7、Model.findByIdAndUpdate()8、Model.findOne()9、Model.findOneAndDelete()10、Model.findOneAndRemove()11、Model.findOneAndUpdate()12、Model.replaceOne()13、Model.updateMany()14、Model.updateOne() 除了这些内置的 CURD 之外，我们还可以对其进行扩展。扩展分为静态方法与实例方法，实例方法一般不用，这里展示静态方法的封装： 123456UserSchema.statics.findBySn=function(sn,callback)&#123; //通过 find 方法获取 sn 的数据，this 指向当前的model this.find(&#123;\"sn\":sn&#125;,function(err,docs)&#123; callback(err,docs) &#125;) &#125; 外部调用 findBySn 12345678UserModel.findBySn('12345678',function(err,docs)&#123; if(err)&#123; console.log(err); return; &#125; console.log(docs)&#125;)","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose模式修饰符","slug":"2","date":"2018-09-10T12:29:22.000Z","updated":"2019-08-18T15:17:25.120Z","comments":true,"path":"2018/09/10/2/","link":"","permalink":"https://herrludwig.github.io/2018/09/10/2/","excerpt":"","text":"一、预定义模式修饰符mongoose 提供了一些预定义模式修饰符可以对我们增加的数据进行格式化。其中 lowercase/uppercase 可以转换字符串的大小写，trim 能够对字段两端去空格。在我们封装model的时候把预定义模式修饰符加进去，如下所示，就可以实现增加数据的格式化。 1234567891011121314var UserSchema=mongoose.Schema(&#123; name:&#123; type:String, name:trim &#125;, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 这样当我们增加的数据 name 为“ Tom ”时，实际录入的 name 就被格式化成了“Tom”。大小写的转换也是同样的道理。 二、自定义模式修饰符除了 mongoose 内置的修饰符以外，我们还可以通过 set（建议使用）修饰符在增加数据的时候对数据进行格式化。也可以通过 get（不建议使用）在实例获取 model 里面数据的时候对数据进行格式化。下面这个例子展示了 set 修饰符的用法，实现了把地址加上’http://‘的格式化： 1234567891011121314151617181920212223242526272829303132var mongoose=require('./db.js');var FocusSchema=mongoose.Schema(&#123; title:&#123; type:String, lowercase:true //预定义的小写格式化 &#125;, redirect:&#123; type:String, set(parmas)&#123; //增加数据的时候对redirect字段进行处理，parmas可以获取redirect的值 if(!parmas)&#123; return '' &#125;else&#123; if(parmas.indexOf('http://')!=0 &amp;&amp; parmas.indexOf('https://')!=0)&#123; //indexOf查找位置，如果在首位则返回0，不存在则返回-1，如果在后面则返回的是正数 return 'http://'+parmas; &#125; return parmas &#125; &#125; &#125;, status:&#123; type:Number, default:1 &#125;&#125;)module.exports=mongoose.model('Focus',FocusSchema,'focus'); 即如果用户输入的是 www.baidu.com, 则保存为 http://www.baidu.com；如果是 http://www.baidu.com，则仍为 http://www.baidu.com","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose的增删改查及模块化","slug":"1","date":"2018-09-07T10:34:52.000Z","updated":"2019-08-18T15:09:11.786Z","comments":true,"path":"2018/09/07/1/","link":"","permalink":"https://herrludwig.github.io/2018/09/07/1/","excerpt":"","text":"一、mongoose的增删改查下面的例子展示了 mongoose 操作 MongoDB 实现增删改查的操作，要注意的是删和改要先获取’_id’ 12345678var u=new User(&#123; //实例化model，增加数据 name:'Tom', age:20, status:1&#125;)u.save(); 12345678User.deleteOne(&#123; '_id': '5b72ada84e284f0acc8d318a' &#125;, function (err) &#123; if (err) &#123; console.log(err); return; &#125; console.log('删除成功');&#125;) 12345678User.updateOne(&#123; '_id': '5b72ada84e284f0acc8d318a' &#125;, &#123; name: 'Ben' &#125;, function(err) &#123; if(err)&#123; console.log(err); return; &#125; console.log('修改成功')&#125;) 12345678User.find(&#123;&#125;,function(err,docs)&#123; //未限定条件即为全部查找 if(err)&#123; console.log(err); return; &#125; console.log(docs);&#125;) 二、mongoose的模块化进行模块化可以达到提高运行效率、精简代码的功效。首先我们在项目里新建一个 model 文件夹，将需要的模块放进去，这里举两个例子： 在 model 文件夹里新建一个 db.js，封装连接数据库的模块。 123456789101112var mongoose=require('mongoose'); //引入的mongoose是工具mongoose.connect('mongodb://127.0.0.1:27017/test',&#123; useNewUrlParser: true &#125;,function(err)&#123; if(err)&#123; console.log(err); return; &#125; console.log('数据库连接成功')&#125;)；module.exports=mongoose; //暴露的mongoose是我们定义的模块 在 model 文件夹里新建一个 user.js，封装用户模块，此为操作 user 表的模块 1234567891011121314var mongoose=require('./db.js'); //首先引入我们刚封装的db模块var UserSchema=mongoose.Schema(&#123; //然后定义Schema name:String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;)module.exports=mongoose.model('User',UserSchema,'user'); //最后定义UserModel并暴露出去,这里用了简写 在封装完以上两个模块之后，我们就可以在外部进行调用了，例如在外部的 app.js 里我们可以这样增加并查找数据： 1234567891011121314151617181920212223var UserModel=require('./model/user.js');var user=new UserModel(&#123; //增 name:\"Tom\", age:20&#125;)user.save(function(err)&#123; //存 if(err)&#123; console.log(err); return; &#125; UserModel.find(&#123;&#125;,function(err,docs)&#123; //找 if(err)&#123; console.log(err); return; &#125; console.log(docs); &#125;)&#125;) 三、解惑Q：“我们注意到每封装一个新模块都要调用一次 db.js，那么会不会使 MongoDB 多次重连而导致性能变差？”A：并不会，因为 mongoose 底层用到了单例模式，所以数据库只会连接一次，连接之后其余模块的运行时间会大大缩短，从而保证了性能。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose入门介绍","slug":"test","date":"2018-09-05T08:14:16.000Z","updated":"2019-08-18T15:08:40.387Z","comments":true,"path":"2018/09/05/test/","link":"","permalink":"https://herrludwig.github.io/2018/09/05/test/","excerpt":"","text":"一、mongoose介绍Mongoose 是在 Node.js 异步环境下对 MongoDB 进行便捷操作的对象模型工具。Mongoose 有两个特点： 通过关系型数据库的思想来设计非关系型数据库 简化对 MongoDB 的操作 二、安装及使用1. 安装1npm i mongoose --save 2. 引入并连接12const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test',&#123; useNewUrlParser: true &#125;); 3. 定义SchemaSchema 为数据库对象的集合。Schema 是 Mongoose 里用到的一种数据模式，可以理解为“表”结构的定义。每个 Schema 会映射到 Mongodb 中的一个 collection。下图展示了SQL与NoSQL的异同： 12345678910var UserSchema=mongoose.Schema(&#123; // 注意：字段名称必须和collection保持一致 name: String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 4. 创建数据模型modelmodel 是由 Schema 生成的模型，可以对数据库进行操作，而 Schema 不能对数据库进行操作。mongoose.mode 里面可以传入两个或三个参数。 1mongoose.model（参数1：'模型名称'（首字母大写），参数2：XXSchema，参数3：集合名称） 如果传入2个参数的话，这个模型会和模型名称相同的复数的集合建立连接。如通过下面方法创建模型，那么这个模型将会操作 users 这个集合。 1var User=mongoose.model('User', UserSchema) 如果传入3个参数的话，模型默认操作第三个参数定义的集合名称。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]}]}