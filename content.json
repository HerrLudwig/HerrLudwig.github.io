{"meta":{"title":"Ludwig's blog","subtitle":null,"description":null,"author":"HerrLudwig","url":"https://herrludwig.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T06:57:02.000Z","updated":"2019-08-06T06:58:51.157Z","comments":true,"path":"categories/index.html","permalink":"https://herrludwig.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-06T06:59:16.000Z","updated":"2019-08-06T07:05:11.406Z","comments":true,"path":"tags/index.html","permalink":"https://herrludwig.github.io/tags/index.html","excerpt":"","text":""},{"title":"whoami","date":"2019-08-06T07:04:22.000Z","updated":"2019-08-09T00:19:27.365Z","comments":true,"path":"whoami/index.html","permalink":"https://herrludwig.github.io/whoami/index.html","excerpt":"","text":"博主简介华中科技大学 / 软件工程 / 硕士研究生 吉他手 / 胶佬 / Sneaker / 摄影爱好者 感谢您浏览我的博客，我是Ludwg，目前正在努力学习前端技术。如果我的博客能有一点点帮到您，那真是太好了！"}],"posts":[{"title":"Koa中间件","slug":"8","date":"2018-11-12T08:41:46.000Z","updated":"2019-08-29T14:55:08.169Z","comments":true,"path":"2018/11/12/8/","link":"","permalink":"https://herrludwig.github.io/2018/11/12/8/","excerpt":"","text":"一、什么是 Koa 中间件通俗的讲中间件就是在匹配路由之前或者匹配路由完成后做的一系列的操作，我们就可以把它叫做中间件。express 的中间件 (Middleware) 是一个函数，它可以访问请求对象 (request object / req) 与响应对象 (response object / res)。web 应用中处理“请求-响应循环”流程的中间件，一般被命名为 next 变量。Koa 的中间件和 express 有点类似。中间件的功能包括：1、执行任何代码。2、修改请求和响应对象。3、终结请求-响应循环。4、调用堆栈中的下一个中间件。中间件的标志是next，如果在 get、post 回调函数中没有 next 参数，那么匹配上第一个路由之后就不会往下匹配了。如果想继续往下匹配的话就需要写 next() 二、Koa 中可使用的中间件：主要分为四种：应用级中间件、路由级中间件、错误处理中间件、第三方中间件 1. 应用级中间件123456//匹配任何路由之前打印日期app.use(async (ctx,next)=&gt;&#123; //不写next路由就会终止 console.log(new Date()); await next(); //当前路由匹配完成以后继续向下匹配&#125;) 2. 路由级中间件12345678910// 匹配到news路由以后继续向下匹配router.get('/news',async (ctx,next)=&gt;&#123; //实现先打印后访问 console.log('这是一个新闻'); await next();&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body='这是一个新闻';&#125;) 3. 错误处理中间件12345678910111213//输入路由app.use(async (ctx,next)=&gt;&#123; console.log('这是错误处理中间件'); //先打印这个 await next(); if(ctx.status==404)&#123; //如果页面找不到 ctx.status = 404; ctx.body=\"404 页面\" &#125;else&#123; console.log(ctx.url); //如果页面找得到，先执行页面，最后打印其 url &#125;&#125;) 4. 第三方中间件12345678const static = require('koa-static');const staticPath = './static';app.use(static( path.join( __dirname, staticPath)))const bodyParser = require('koa-bodyparser');app.use(bodyParser()); 三、Koa 中间件的执行顺序Koa 的中间件和 Express 不同，Koa 选择了洋葱模型。 1234567891011121314151617181920212223//输入www.域名.com/newsapp.use(async (ctx,next)=&gt;&#123; console.log('1、第一个中间件'); await next(); console.log('5、匹配路由完成以后又会返回来执行中间件');&#125;)app.use(async (ctx,next)=&gt;&#123; console.log('2、第二个中间件'); await next(); console.log('4、匹配路由完成以后又会返回来执行中间件');&#125;)router.get('/news',async (ctx)=&gt;&#123; console.log('3、匹配到了news路由'); ctx.body='这是一个新闻';&#125;)//执行顺序12345","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"Koa路由、get传值、动态路由","slug":"7","date":"2018-11-09T05:02:25.000Z","updated":"2019-08-21T02:25:58.011Z","comments":true,"path":"2018/11/09/7/","link":"","permalink":"https://herrludwig.github.io/2018/11/09/7/","excerpt":"","text":"一、Koa路由路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，应用涉及到如何响应客户端对某个网站节点的访问。通俗的讲：路由就是根据不同的 URL 地址，加载不同的页面，实现不同的功能。Koa 中的路由和 Express 有所不同，在 Express 中直接引入 Express 就可以配置路由，但是在 Koa 中我们需要安装对应的 koa-router 路由模块来实现。 1npm install --save koa-router 1234567891011121314151617const Koa = require('koa');const router = require('koa-router')(); //注意引入的方式const app = new Koa()router.get('/',async (ctx)=&gt;&#123; //context上下文，包含了req与res ctx.body=\"首页\" //相当于原生里面的res.writeHead() 和 res.end()&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body=\"新闻\"&#125;);app.use(router.routes()) //启动路由app.use(router.allowedMethods()) //在所有路由中间件中最后调用app.listen(3000) 二、Koa 路由 get 传值在 Koa 中 GET 传值通过 request 接收，但是接收的方法有两种：query 和 querystring。1、query：返回的是格式化好的参数对象2、querystring：返回的是请求字符串 123456789router.get('/newscontent',(ctx,next)=&gt;&#123; //从ctx中读取get传值 console.log(ctx.query) //&#123; aid: '123' &#125;，获取的是对象。用的最多的方式 console.log(ctx.querystring) //aid=123&amp;name=zhangsan，获取的是一个字符串 console.log(ctx.url) //获取url地址 ctx.body=\"新闻详情\";&#125;); 三、Koa 动态路由动态路由传值的获取方法：http://域名/newscontent/xxxx 123456router.get('/newscontent/:aid',async (ctx)=&gt;&#123; console.log(ctx.params); //&#123; aid: 'xxxx' &#125; ctx.body=\"新闻详情\";&#125;) 动态路由里面可以传入多个值 /newscontent/:aid/:cid","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"Koa框架介绍、环境搭建以及异步的使用","slug":"6","date":"2018-11-05T09:52:09.000Z","updated":"2019-08-21T02:26:43.322Z","comments":true,"path":"2018/11/05/6/","link":"","permalink":"https://herrludwig.github.io/2018/11/05/6/","excerpt":"","text":"一、Koa框架介绍Node.js 是一个异步的世界，官方 API 支持的都是 callback 形式的异步编程模型。这会带来许多问题，例如：1、callback 嵌套问题；2、异步函数中可能同步调用 callback 返回数据，带来不一致性。为了解决以上问题，Koa 出现了。Koa 是一个由 Express 幕后的原班人马打造的 web 框架， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过使用 Es7 中的 async 和 await，Koa 帮你丢弃回调函数，并有力地提升错误处理效率。 Koa 并没有捆绑任何中间件，而是提供了一个轻量优雅的函数库，使得编写服务端应用变得得心应手。Koa 的开发思路和 express 差不多，最大的特点就是可以避免异步嵌套。Koa基于最新的Es6、Es7语法，运行速度比Express更快。目前阿里就在使用 Koa 框架，并在 Koa 基础上面做了一些扩展和封装开发了一个开源框架 Egg.js。 二、Koa框架的安装使用1、安装 Node.js 8.x 以上的版本Koa要求 Node.js 的版本高于 V7.6。因为 Node.js 7.6 版本开始完全支持 async/await，所以才能完全支持我们的 Koa2。2、安装使用：首先打开项目文件夹 1npm init 生成 package.json 来管理项目的各种模块 1npm install --save koa / cnpm install --save koa –save 表示自动修改 package.json 文件，自动添加依赖项。 123456789const koa=require('koa');const app=new koa();app.use(async(ctx)=&gt;&#123; //配置中间件 （可以先当做路由） ctx.body='hello koa'&#125;)app.listen(3000); 三、Koa常用的ES6语法1、let和const（都是块作用域）2、模板字符串 123let name='Sam'let age=20console.log(`$&#123;name&#125;的年龄是$&#123;age&#125;`) 3、属性和方法的简写 1234567891011let name='Sam'var app=&#123; name, run()&#123; console.log(`$&#123;this.name&#125;在跑步`) &#125;&#125;app.run() 4、箭头函数：this 指向上下文，function() 变成 ()=&gt;5、Promise 123456789101112131415function getData(resolve,reject)&#123; setTimeout(()=&gt;&#123; var name='Sam' resolve(name) &#125;,1000);&#125;var p=new Promise(getData)p.then((data)=&gt;&#123; console.log(data)&#125;) 四、Koa异步处理Async、Await和Promise的使用async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。简单理解：async 是让方法变成异步。await 是等待异步方法执行完成。详细说明： 1234567async function testAsync()&#123; return 'Hello async';&#125;const result = testAsync();console.log(result); async 是让方法变成异步，在终端里用 node 执行这段代码，你会发现输出了 1Promise &#123; 'Hello async' &#125; 即返回的是 Promise。 await 在等待 async 方法执行完毕，其实 await 等待的只是一个表达式，这个表达式在官方文档里说的是 Promise 对象，但是它也可以接受普通值。注意：await 必须在 async 方法中才可以使用，因为 await 访问本身会造成程序堵塞，所以必须在异步方法中才可以使用。 12345678910111213141516async function getData()&#123; console.log(2)&#125;async function test()&#123; console.log(1) var d=await getData() console.log(d) console.log(3)&#125;test()//运行结果是1 2 3 await的阻塞功能把异步改成了同步 async/await 同时使用：async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。 1234567891011121314151617function findData() &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; var name='Same' resolve(name) &#125;,1000) &#125;) //定义一个返回promise的方法&#125;async function test() &#123; const v = await findData() console.log(v)&#125;test()","categories":[{"name":"Koa","slug":"Koa","permalink":"https://herrludwig.github.io/categories/Koa/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://herrludwig.github.io/tags/web框架/"}]},{"title":"CommonJs、Node.js 自定义模块、NPM 以及 package.json","slug":"11","date":"2018-10-09T08:21:42.000Z","updated":"2019-08-29T14:48:15.532Z","comments":true,"path":"2018/10/09/11/","link":"","permalink":"https://herrludwig.github.io/2018/10/09/11/","excerpt":"","text":"一、什么是 CommonJs？JavaScript 有很多快速高效的解释器。然而，JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序，并没有制定一个用于更广泛的应用程序的标准库。CommonJS 规范的提出主要是为了弥补当前 JavaScript 没有标准的缺陷。它的终极目标是提供一个类似于 Python、Ruby 和 Java 语言的标准库,而不只是停留在小脚本程序的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript 开发客户端应用， 而且还可以编写以下应用： 服务器端 Node.js 应用程序。 命令行工具。 桌面图形界面应用程序。CommonJS 就是模块化的标准，Node.js 就是 CommonJS 模块化的实现。Node 应用由模块组成，采用 CommonJS 模块规范。 二、Node.js 中的模块化1. 在 Node 中，模块分为两类:一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。 核心模块部分在 Node 源代码的编译过程中编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进了内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。比如 HTTP 模块、URL 模块、fs 模块都是 Node.js 内置的核心模块，可以直接引入使用。 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度相比核心模块稍微慢一些，但是用的非常多。些模块需要我们自己定义。 2. CommonJS (Node.js) 中自定义模块的规定： 我们可以把公共的功能抽离成为一个单独的 js 文件作为一个模块，默认情况下这个模块里面的方法或者属性外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过 exports 或者 module.exports 暴露该属性或者方法。 在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可以使用模块里面暴露的属性和方法。 3. 模块的定义与使用比如定义一个 tools.js 的模块，如果这个模块不在当前目录里面，node会默认从node_modules文件夹里面寻找。 12345678910111213//模块定义var tools = &#123; sayHello: function()&#123; return 'hello Node'; &#125;, add: function(x,y)&#123; return x + y; &#125;&#125;;// 模块接口的暴露// module.exports = tools;exports.sayHello = tools.sayHello;exports.add = tools.add; 12345// 引入自定义的 tools.js 模块var tools = require('./tools'); console.log(tools.sayHello()); //使用模块console.log(tools.add(1,2)); 三、包与NPM1. 包Node.js 中除了它自己提供的核心模块外，我们可以自定义模块，也可以使用第三方的模块。Nodejs 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。完全符合 CommonJS 规范的包的目录一般包含如下这些文件： package.json：包描述文件。 bin：用于存放可执行二进制文件的目录。 lib：用于存放 JavaScript 代码的目录。 doc：用于存放文档的目录。 2. NPM介绍npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包，这些源代码（包）我们可以在 https://www.npmjs.com 找到。npm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的使用场景有： 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。 允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用。（比如 supervisor） 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。 3. NPM命令123456npm -v //查看 npm 版本npm install ModuleName //使用 npm 命令安装模块npm uninstall ModuleName //卸载模块npm list //查看当前目录下已安装的包npm info ModuleName //查看模块的版本npm install jquery@1.8.0 //指定版本安装 四、package.json每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。在把项目发给别人时是不发 node_modules 文件夹的，但是可以通过 npm install 命令根据这个配置文件自动下载所需的模块，也就是配置项目所需的运行和开发环境。 我们每次使用 npm install xxx 都会把内容记录到 package.json 文件中，包都会发生变化，为了系统的稳定性考虑，每次执行完 npm install 之后会对应生成 package-lock 文件，该文件记录了上一次安装的具体的版本号。当你执行 npm install 的时候，node 会先从 package.json 文件中读取所有 dependencies 信息，然后与 node_modules 中的模块进行对比，没有的直接下载，node 是从 package.json 文件读取模块名称，从 package-lock.json 文件中获取版本号，然后进行下载或者更新。 如果 package.json 与 package-lock.json 都不存在，执行 npm install 时 node 会重新生成 package-lock.json 文件，然后把 node_modules 中的模块信息全部记入 package-lock.json 文件，但不会生成 package.json 文件。我们可以通过 npm init –yes 来生成 package.json 文件。为了将模块写入 package.json，在安装模块时我们需要这么写： 12npm install 模块 --save //写入dependenciesnpm install 模块 --save-dev //写入devDependencies dependencies 与 devDependencies 的区别?dependencie 配置当前程序所依赖的其他包。devDependencie 配置当前程序所依赖的其他包，只会下载模块，而不下载这些模块的测试和文档框架“dependencies”: { “ejs”: “^2.3.4”, “express”: “^4.13.3”, “formidable”: “^1.0.17”}^表示第一位版本号不变，后面两位取最新的~表示前两位不变，最后一个取最新*表示全部取最新","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://herrludwig.github.io/categories/Node-js/"}],"tags":[{"name":"运行环境","slug":"运行环境","permalink":"https://herrludwig.github.io/tags/运行环境/"}]},{"title":"Node.js的创建服务以及HTTP模块、URL模块","slug":"10","date":"2018-10-06T04:01:02.000Z","updated":"2019-08-29T14:48:50.450Z","comments":true,"path":"2018/10/06/10/","link":"","permalink":"https://herrludwig.github.io/2018/10/06/10/","excerpt":"","text":"一、Node.js创建应用如果我们使用 PHP 来编写后端的代码时，需要使用 Apache 或者 Nginx 的 HTTP 服务器来处理客户端的请求。不过对 Node.js 来说概念就完全不一样了。使用 Node.js 时，我们不仅仅在实现一个应用，同时还实现了整个 HTTP 服务器。 1. 引入 http 模块1var http = require(\"http\"); 2. 创建服务器接下来我们使用 http.createServer( ) 方法创建服务器，并使用 listen 方法绑定 8888 端口。函数通过 request / response 参数来接收和响应数据。 123456789101112131415var http = require('http');http.createServer(function (req,res)&#123;// 发送 HTTP 头部// HTTP 状态值: 200 : OK// 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf-8 res.writeHead(200,&#123;\"Content-Type\":\"text/html;charset=UTF-8\"&#125;); res.write('hello node')// 结束响应 res.end(\"我买了一个 iPhone\" + (1+2+3) + \"s\"); &#125;).listen(8888); // 监听端口 3. 运行程序用命令行切换到程序对应目录，通过 node 文件名.js 命令运行程序。浏览器输入 localhost:8888 查看结果。有了 node，我们任何一个 js 文件都可以通过 node 来运行。也就是说 node 就是一个 js 的运行环境。 二、HTTP模块的使用12345678910111213// 引入http模块var http = require(\"http\");// 创建一个服务器，回调函数表示接收到请求之后做的事情http.createServer(function(req,res)&#123;// req 获取 url，res 返回响应信息 console.log(\"服务器接收到了请求\" + req.url); res.end(); // 使 Web 服务器停止处理脚本并返回当前结果&#125;);server.listen(3000); req 里面最关键的就是 req.url 属性，表示请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。我们比较关心的不是拿到 URL，而是识别这个 URL，这就用到了下面的 URL 模块。 三、URL模块的使用123url.parse() // 解析 URLurl.format(urlObject) // 是上面 url.parse() 操作的逆向操作url.resolve(from, to) // 添加或者替换地址 1. url.parse() 的用法从命令行里输入 node 回车，之后使用该方法除此之外还能拿到目录和 get 传值 2. url.format()将上述解析的内容放到括号里，返回出地址，用的比较少 3. url.resolve()可以替换url里面的二级目录以及追加目录 示例：输入 http://localhost:8001/news?aid=123&amp;cid=3 拿到 aid 和 cid 12345678910111213141516171819var http=require('http');var url=require('url');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;\"Content-Type\":\"text/html;charset='utf-8'\"&#125;); if(req.url!='/favicon.ico')&#123; //图标是多余信息 var result=url.parse(req.url,true); //第一个参数是地址，第二个参数 true 表示把 get 传值转换成对象 console.log('aid='+result.query.aid); /*获取url的get传值*/ console.log('cid='+result.query.cid); &#125;else&#123; res.end('icon'); &#125; res.end('get'); /*结束响应*/&#125;).listen(8001);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://herrludwig.github.io/categories/Node-js/"}],"tags":[{"name":"运行环境","slug":"运行环境","permalink":"https://herrludwig.github.io/tags/运行环境/"}]},{"title":"为什么选择Node.js","slug":"9","date":"2018-10-03T12:11:08.000Z","updated":"2019-08-29T14:56:07.886Z","comments":true,"path":"2018/10/03/9/","link":"","permalink":"https://herrludwig.github.io/2018/10/03/9/","excerpt":"","text":"一、Node.js介绍Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，非常适合在分布式设备上运行数据密集型的实时应用。它让 JavaScript 可以开发后端程序，实现几乎所有其他后端语言所能实现的功能。 二、Node.js的优势1. Node.js 语法完全是 JS 语法只要有 JS 基础就可以学会 Node.js 后端开发。前后端编程环境统一，可以大大降低开发成本。 2. Node.js 超强的高并发能力现在的服务器端语言中存在着一些问题。在 Java、PHP 或者 .net 等服务器端语言中，会为每一个客户端的连接创建一个新的线程。而每个线程需要耗费大约 2MB 内存。也就是说理论上，一个 8GB 内存的服务器可以同时连接的最大用户数为四千个左右。要让 Web 应用程序支持更多的用户，硬件成本当然就上升了。而 Node.js 不为每个连接创建一个新的线程，仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞 I/O 和事件驱动机制让 Node.js 程序宏观上也是并行的。使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过四万用户的连接。 3. 实现高性能服务器在服务器中经常需要处理各种二进制数据。但 JavaScript 只具有非常有限的对二进制数据的处理能力，而 Node.js 所提供的 Buffer 类则大大增强了其处理能力。另外在 V8 引擎内部使用了一种全新的编译技术。这使 JavaScript 代码与 C 语言代码具有非常相近的执行效率。 三、Node.js 适合做什么","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://herrludwig.github.io/categories/Node-js/"}],"tags":[{"name":"运行环境","slug":"运行环境","permalink":"https://herrludwig.github.io/tags/运行环境/"}]},{"title":"aggregate聚合管道","slug":"5","date":"2018-09-16T10:36:27.000Z","updated":"2019-08-18T15:23:43.146Z","comments":true,"path":"2018/09/16/5/","link":"","permalink":"https://herrludwig.github.io/2018/09/16/5/","excerpt":"","text":"一、管道操作符与表达式管道操作符作为“键”，所对应的“值”叫做管道表达式。例如 1&#123;$match:&#123;status:\"A\"&#125;&#125; $match 称为管道操作符，而 status:”A” 称为管道表达式，是管道操作符的操作数(Operand)。每个管道表达式是一个文档结构，它是由字段名、字段值、和一些表达式操作符组成的。 二、在MongoDB中使用聚合管道使用聚合管道可以对集合中的文档进行变换和组合。在实际项目中聚合管道多用于表关联查询和数据的统计。在 MongoDB 中使用 db.集合名.aggregate([{ },…]) 的方法来构建和使用聚合管道。下图为官网给出的实例： 三、mongoose aggregate多表关联查询mongoose 里聚合管道的语法与 MongoDB 中相似。以淘宝订单与订单详情为例，为了将订单表与订单物品关联起来，先在 model 里封装好 order.js 与 order_item.js，然后只将 order model 引入主程序 123456789101112131415161718192021222324var OrderModel=require('./model/order.js');OrderModel.aggregate([&#123; $lookup: &#123; from: \"order_item\", localField: \"order_id\", foreignField: \"order_id\", //通过order_id关联起来 as: \"items\" &#125; &#125;, &#123; $match: &#123; \"all_price\": &#123; $gte: 90 &#125; &#125; //筛选总价大于90的 &#125;], function (err, docs) &#123; if (err) &#123; console.log(err) return; &#125; console.log(JSON.stringify(docs))&#125;)//然后 node .\\app.js 终端运行 通过以上示例我们实现了两个表之间的关联查询，由于管道并没有数量限制，因此我们可以通过同样的方式实现多个表之间的关联查询。如下图所示，如果我们想查询文章信息，同时显示文章的分类以及作者信息，就需要使用聚合管道将这三个表关联起来。 12345678910111213141516171819202122232425var ArticleModel=require('./model/article.js'); //查哪个表就引入哪个表ArticleModel.aggregate([&#123; $lookup: &#123; from: \"articlecate\", localField: \"cid\", //分类表的_id对应文章表的cid foreignField: \"_id\", as: \"cate\" &#125; &#125;, &#123; $lookup: &#123; from: \"user\", localField: \"author_id\", //作者表的_id对应文章表的author_id foreignField: \"_id\", as: \"user\" &#125; &#125;], function (err, docs) &#123; console.log(JSON.stringify(docs));&#125;)","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose数据校验","slug":"4","date":"2018-09-14T12:16:15.000Z","updated":"2019-08-18T15:21:54.780Z","comments":true,"path":"2018/09/14/4/","link":"","permalink":"https://herrludwig.github.io/2018/09/14/4/","excerpt":"","text":"一、校验参数1、required: 表示这个数据必须传入2、max: 用于 Number 类型数据，最大值3、min: 用于 Number 类型数据，最小值4、enum：枚举类型，要求数据必须满足枚举值 enum: [‘0’, ‘1’, ‘2’]，用于 string5、match：增加的数据必须符合 match 正则表达式，用于 string6、maxlength：最大长度，用于 string7、minlength：最小长度例如在定义 Schema 时加入校验参数 12345678910111213141516171819202122232425262728var UserSchema=mongoose.Schema(&#123; name:&#123; type:String, //指定类型 trim:true, //去空格 required:true //name必须传入 &#125;, sn:&#123; type:String, index:true, //索引. match:/^sn(.*)/i, //必须以sn为开头，忽略大小写 minlength:10 &#125;, age:&#123; type:Number, min:0, //用在number类型上面 max:150 &#125;, status:&#123; type:String, default:'success', //默认值 enum:['success','error'] //status的值必须在对应的数组里面，注意枚举是用于String &#125;&#125;) 二、自定义验证器与自定义修饰符 set 相似，我们可以使用 validate 来自定义验证器。如果通过验证就返回 true，没有通过则返回 false。在上个例子中 sn 可以改成如下自定义验证器： 123456789sn:&#123; type:String, index:true, //索引. match:/^sn(.*)/i, //必须以sn为开头，忽略大小写 validate: function(sn) &#123; return sn.length &gt;= 10; //sn长度大于等于10 &#125; &#125;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose索引","slug":"3","date":"2018-09-11T13:18:02.000Z","updated":"2019-08-18T15:19:10.914Z","comments":true,"path":"2018/09/11/3/","link":"","permalink":"https://herrludwig.github.io/2018/09/11/3/","excerpt":"","text":"一、设置索引索引是对数据库表中一列或多列的值进行排序的一种结构，可以让我们查询数据库变得更快。MongoDB 的索引几乎与传统的关系型数据库一模一样，在 mongoose 中可以在定义 Schema 的时候创建索引。 12345678910111213var DeviceSchema = new mongoose.Schema(&#123; sn: &#123; type: Number, unique: true // 唯一索引 &#125;, name: &#123; type: String, index: true // 普通索引 &#125;&#125;) 二、CURDCURD代表创建（Create）、更新（Update）、读取（Retrive）和删除（Delete）操作，mongoose 中内置的 CURD 有如下这些：https://mongoosejs.com/docs/queries.html1、Model.deleteMany()2、Model.deleteOne()3、Model.find()4、Model.findById()5、Model.findByIdAndDelete()6、Model.findByIdAndRemove()7、Model.findByIdAndUpdate()8、Model.findOne()9、Model.findOneAndDelete()10、Model.findOneAndRemove()11、Model.findOneAndUpdate()12、Model.replaceOne()13、Model.updateMany()14、Model.updateOne() 除了这些内置的 CURD 之外，我们还可以对其进行扩展。扩展分为静态方法与实例方法，实例方法一般不用，这里展示静态方法的封装： 123456UserSchema.statics.findBySn=function(sn,callback)&#123; //通过 find 方法获取 sn 的数据，this 指向当前的model this.find(&#123;\"sn\":sn&#125;,function(err,docs)&#123; callback(err,docs) &#125;) &#125; 外部调用 findBySn 12345678UserModel.findBySn('12345678',function(err,docs)&#123; if(err)&#123; console.log(err); return; &#125; console.log(docs)&#125;)","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose模式修饰符","slug":"2","date":"2018-09-10T12:29:22.000Z","updated":"2019-08-18T15:17:25.120Z","comments":true,"path":"2018/09/10/2/","link":"","permalink":"https://herrludwig.github.io/2018/09/10/2/","excerpt":"","text":"一、预定义模式修饰符mongoose 提供了一些预定义模式修饰符可以对我们增加的数据进行格式化。其中 lowercase/uppercase 可以转换字符串的大小写，trim 能够对字段两端去空格。在我们封装model的时候把预定义模式修饰符加进去，如下所示，就可以实现增加数据的格式化。 1234567891011121314var UserSchema=mongoose.Schema(&#123; name:&#123; type:String, name:trim &#125;, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 这样当我们增加的数据 name 为“ Tom ”时，实际录入的 name 就被格式化成了“Tom”。大小写的转换也是同样的道理。 二、自定义模式修饰符除了 mongoose 内置的修饰符以外，我们还可以通过 set（建议使用）修饰符在增加数据的时候对数据进行格式化。也可以通过 get（不建议使用）在实例获取 model 里面数据的时候对数据进行格式化。下面这个例子展示了 set 修饰符的用法，实现了把地址加上’http://‘的格式化： 1234567891011121314151617181920212223242526272829303132var mongoose=require('./db.js');var FocusSchema=mongoose.Schema(&#123; title:&#123; type:String, lowercase:true //预定义的小写格式化 &#125;, redirect:&#123; type:String, set(parmas)&#123; //增加数据的时候对redirect字段进行处理，parmas可以获取redirect的值 if(!parmas)&#123; return '' &#125;else&#123; if(parmas.indexOf('http://')!=0 &amp;&amp; parmas.indexOf('https://')!=0)&#123; //indexOf查找位置，如果在首位则返回0，不存在则返回-1，如果在后面则返回的是正数 return 'http://'+parmas; &#125; return parmas &#125; &#125; &#125;, status:&#123; type:Number, default:1 &#125;&#125;)module.exports=mongoose.model('Focus',FocusSchema,'focus'); 即如果用户输入的是 www.baidu.com, 则保存为 http://www.baidu.com；如果是 http://www.baidu.com，则仍为 http://www.baidu.com","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose的增删改查及模块化","slug":"1","date":"2018-09-07T10:34:52.000Z","updated":"2019-08-18T15:09:11.786Z","comments":true,"path":"2018/09/07/1/","link":"","permalink":"https://herrludwig.github.io/2018/09/07/1/","excerpt":"","text":"一、mongoose的增删改查下面的例子展示了 mongoose 操作 MongoDB 实现增删改查的操作，要注意的是删和改要先获取’_id’ 12345678var u=new User(&#123; //实例化model，增加数据 name:'Tom', age:20, status:1&#125;)u.save(); 12345678User.deleteOne(&#123; '_id': '5b72ada84e284f0acc8d318a' &#125;, function (err) &#123; if (err) &#123; console.log(err); return; &#125; console.log('删除成功');&#125;) 12345678User.updateOne(&#123; '_id': '5b72ada84e284f0acc8d318a' &#125;, &#123; name: 'Ben' &#125;, function(err) &#123; if(err)&#123; console.log(err); return; &#125; console.log('修改成功')&#125;) 12345678User.find(&#123;&#125;,function(err,docs)&#123; //未限定条件即为全部查找 if(err)&#123; console.log(err); return; &#125; console.log(docs);&#125;) 二、mongoose的模块化进行模块化可以达到提高运行效率、精简代码的功效。首先我们在项目里新建一个 model 文件夹，将需要的模块放进去，这里举两个例子： 在 model 文件夹里新建一个 db.js，封装连接数据库的模块。 123456789101112var mongoose=require('mongoose'); //引入的mongoose是工具mongoose.connect('mongodb://127.0.0.1:27017/test',&#123; useNewUrlParser: true &#125;,function(err)&#123; if(err)&#123; console.log(err); return; &#125; console.log('数据库连接成功')&#125;)；module.exports=mongoose; //暴露的mongoose是我们定义的模块 在 model 文件夹里新建一个 user.js，封装用户模块，此为操作 user 表的模块 1234567891011121314var mongoose=require('./db.js'); //首先引入我们刚封装的db模块var UserSchema=mongoose.Schema(&#123; //然后定义Schema name:String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;)module.exports=mongoose.model('User',UserSchema,'user'); //最后定义UserModel并暴露出去,这里用了简写 在封装完以上两个模块之后，我们就可以在外部进行调用了，例如在外部的 app.js 里我们可以这样增加并查找数据： 1234567891011121314151617181920212223var UserModel=require('./model/user.js');var user=new UserModel(&#123; //增 name:\"Tom\", age:20&#125;)user.save(function(err)&#123; //存 if(err)&#123; console.log(err); return; &#125; UserModel.find(&#123;&#125;,function(err,docs)&#123; //找 if(err)&#123; console.log(err); return; &#125; console.log(docs); &#125;)&#125;) 三、解惑Q：“我们注意到每封装一个新模块都要调用一次 db.js，那么会不会使 MongoDB 多次重连而导致性能变差？”A：并不会，因为 mongoose 底层用到了单例模式，所以数据库只会连接一次，连接之后其余模块的运行时间会大大缩短，从而保证了性能。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose入门介绍","slug":"test","date":"2018-09-05T08:14:16.000Z","updated":"2019-08-18T15:08:40.387Z","comments":true,"path":"2018/09/05/test/","link":"","permalink":"https://herrludwig.github.io/2018/09/05/test/","excerpt":"","text":"一、mongoose介绍Mongoose 是在 Node.js 异步环境下对 MongoDB 进行便捷操作的对象模型工具。Mongoose 有两个特点： 通过关系型数据库的思想来设计非关系型数据库 简化对 MongoDB 的操作 二、安装及使用1. 安装1npm i mongoose --save 2. 引入并连接12const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test',&#123; useNewUrlParser: true &#125;); 3. 定义SchemaSchema 为数据库对象的集合。Schema 是 Mongoose 里用到的一种数据模式，可以理解为“表”结构的定义。每个 Schema 会映射到 Mongodb 中的一个 collection。下图展示了SQL与NoSQL的异同： 12345678910var UserSchema=mongoose.Schema(&#123; // 注意：字段名称必须和collection保持一致 name: String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 4. 创建数据模型modelmodel 是由 Schema 生成的模型，可以对数据库进行操作，而 Schema 不能对数据库进行操作。mongoose.mode 里面可以传入两个或三个参数。 1mongoose.model（参数1：'模型名称'（首字母大写），参数2：XXSchema，参数3：集合名称） 如果传入2个参数的话，这个模型会和模型名称相同的复数的集合建立连接。如通过下面方法创建模型，那么这个模型将会操作 users 这个集合。 1var User=mongoose.model('User', UserSchema) 如果传入3个参数的话，模型默认操作第三个参数定义的集合名称。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]}]}