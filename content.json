{"meta":{"title":"Ludwig's blog","subtitle":null,"description":null,"author":"HerrLudwig","url":"https://herrludwig.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T06:57:02.000Z","updated":"2019-08-06T06:58:51.157Z","comments":true,"path":"categories/index.html","permalink":"https://herrludwig.github.io/categories/index.html","excerpt":"","text":""},{"title":"whoami","date":"2019-08-06T07:04:22.000Z","updated":"2019-08-09T00:19:27.365Z","comments":true,"path":"whoami/index.html","permalink":"https://herrludwig.github.io/whoami/index.html","excerpt":"","text":"博主简介华中科技大学 / 软件工程 / 硕士研究生 吉他手 / 胶佬 / Sneaker / 摄影爱好者 感谢您浏览我的博客，我是Ludwg，目前正在努力学习前端技术。如果我的博客能有一点点帮到您，那真是太好了！"},{"title":"tags","date":"2019-08-06T06:59:16.000Z","updated":"2019-08-06T07:05:11.406Z","comments":true,"path":"tags/index.html","permalink":"https://herrludwig.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mongoose索引","slug":"3","date":"2018-09-11T13:18:02.000Z","updated":"2019-08-13T08:57:54.303Z","comments":true,"path":"2018/09/11/3/","link":"","permalink":"https://herrludwig.github.io/2018/09/11/3/","excerpt":"","text":"一、设置索引索引是对数据库表中一列或多列的值进行排序的一种结构，可以让我们查询数据库变得更快。MongoDB 的索引几乎与传统的关系型数据库一模一样，在 mongoose 中可以在定义 Schema 的时候创建索引。 12345678910var DeviceSchema = new mongoose.Schema(&#123; sn: &#123; type: Number, unique: true // 唯一索引 &#125;, name: &#123; type: String, index: true // 普通索引 &#125;&#125;) 二、CURDCURD代表创建（Create）、更新（Update）、读取（Retrive）和删除（Delete）操作，mongoose中内置的CURD有如下这些：https://mongoosejs.com/docs/queries.html1、Model.deleteMany()2、Model.deleteOne()3、Model.find()4、Model.findById()5、Model.findByIdAndDelete()6、Model.findByIdAndRemove()7、Model.findByIdAndUpdate()8、Model.findOne()9、Model.findOneAndDelete()10、Model.findOneAndRemove()11、Model.findOneAndUpdate()12、Model.replaceOne()13、Model.updateMany()14、Model.updateOne() 除了这些内置的CURD之外，我们还可以对其进行扩展。扩展分为静态方法与实例方法，实例方法一般不用，这里展示静态方法的封装： 123456UserSchema.statics.findBySn=function(sn,callback)&#123; //通过 find 方法获取 sn 的数据，this 指向当前的model this.find(&#123;&quot;sn&quot;:sn&#125;,function(err,docs)&#123; callback(err,docs) &#125;) &#125; 外部调用findBySn 1234567UserModel.findBySn(&apos;12345678&apos;,function(err,docs)&#123; if(err)&#123; console.log(err); return; &#125; console.log(docs)&#125;)","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose预定义模式修饰符","slug":"2","date":"2018-09-10T12:29:22.000Z","updated":"2019-08-09T10:04:42.947Z","comments":true,"path":"2018/09/10/2/","link":"","permalink":"https://herrludwig.github.io/2018/09/10/2/","excerpt":"","text":"一、预定义模式修饰符mongoose 提供了一些预定义模式修饰符可以对我们增加的数据进行格式化。其中 lowercase/uppercase 可以转换字符串的大小写，trim 能够对字段两端去空格。在我们封装model的时候把预定义模式修饰符加进去，如下所示，就可以实现增加数据的格式化。 1234567891011var UserSchema=mongoose.Schema(&#123; name:&#123; type:String, name:trim &#125;, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 这样当我们增加的数据 name 为“ Tom ”时，实际录入的 name 就被格式化成了“Tom”。大小写的转换也是同样的道理。 二、自定义模式修饰符除了 mongoose 内置的修饰符以外，我们还可以通过 set（建议使用）修饰符在增加数据的时候对数据进行格式化。也可以通过 get（不建议使用）在实例获取 model 里面数据的时候对数据进行格式化。下面这个例子展示了set修饰符的用法，实现了把地址加上’http://‘的格式化： 123456789101112131415161718192021var FocusSchema=mongoose.Schema(&#123; title:&#123; type:String, lowercase:true //预定义的小写格式化 &#125;, redirect:&#123; type:String, set(parmas)&#123; //增加数据的时候对redirect字段进行处理，parmas可以获取redirect的值 if(!parmas)&#123; return &apos;&apos; &#125;else&#123; if(parmas.indexOf(&apos;http://&apos;)!=0 &amp;&amp; parmas.indexOf(&apos;https://&apos;)!=0)&#123; //indexOf查找位置，如果在首位则返回0，不存在则返回-1，如果在后面则返回的是正数 return &apos;http://&apos;+parmas; &#125; return parmas &#125; &#125; &#125;, &#125;&#125;) 即如果用户输入的是 www.baidu.com, 则保存为http://www.baidu.com；如果是http://www.baidu.com，则仍为 http://www.baidu.com","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose的增删改查及模块化","slug":"1","date":"2018-09-07T10:34:52.000Z","updated":"2019-08-10T14:54:59.442Z","comments":true,"path":"2018/09/07/1/","link":"","permalink":"https://herrludwig.github.io/2018/09/07/1/","excerpt":"","text":"一、mongoose的增删改查下面的例子展示了mongoose操作MongoDB实现增删改查的操作，要注意的是删和改要先获取’_id’ 123456var u=new User(&#123; //实例化model，增加数据 name:&apos;Tom&apos;, age:20, status:1 &#125;)u.save(); 1234567User.deleteOne(&#123; &apos;_id&apos;: &apos;5b72ada84e284f0acc8d318a&apos; &#125;, function (err) &#123; if (err) &#123; console.log(err); return; &#125; console.log(&apos;删除成功&apos;);&#125;); 1234567User.updateOne(&#123; &apos;_id&apos;: &apos;5b72ada84e284f0acc8d318a&apos; &#125;, &#123; name: &apos;Ben&apos; &#125;, function(err) &#123; if(err)&#123; console.log(err); return; &#125; console.log(&apos;修改成功&apos;)&#125;) 1234567User.find(&#123;&#125;,function(err,docs)&#123; //未限定条件即为全部查找 if(err)&#123; console.log(err); return; &#125; console.log(docs);&#125;) 二、mongoose的模块化进行模块化可以达到提高运行效率、精简代码的功效。首先我们在项目里新建一个model文件夹，将需要的模块放进去，这里举两个例子： 在model文件夹里新建一个db.js，封装连接数据库的模块。 123456789var mongoose=require(&apos;mongoose&apos;); //引入的mongoose是工具mongoose.connect(&apos;mongodb://127.0.0.1:27017/test&apos;,&#123; useNewUrlParser: true &#125;,function(err)&#123; if(err)&#123; console.log(err); return; &#125; console.log(&apos;数据库连接成功&apos;)&#125;)；module.exports=mongoose; //暴露的mongoose是我们定义的模块 在model文件夹里新建一个user.js，封装用户模块，此为操作user表的模块 12345678910var mongoose=require(&apos;./db.js&apos;); //首先引入我们刚封装的db模块var UserSchema=mongoose.Schema(&#123; //然后定义Schema name:String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;)module.exports=mongoose.model(&apos;User&apos;,UserSchema,&apos;user&apos;); //最后定义UserModel并暴露出去,这里用了简写 在封装完以上两个模块之后，我们就可以在外部进行调用了，例如在外部的app.js里我们可以这样增加并查找数据： 12345678910111213141516171819var UserModel=require(&apos;./model/user.js&apos;);var user=new UserModel(&#123; //增 name:&quot;Tom&quot;, age:20&#125;)user.save(function(err)&#123; //存 if(err)&#123; console.log(err); return; &#125; UserModel.find(&#123;&#125;,function(err,docs)&#123; //找 if(err)&#123; console.log(err); return; &#125; console.log(docs); &#125;)&#125;) 三、答疑Q：“我们注意到每封装一个新模块都要调用一次db.js，那么会不会使MongoDB多次重连而导致性能变差？”A：并不会，因为mongoose底层用到了单例优化，所以数据库只会连接一次，连接之后其余模块的运行时间会大大缩短，从而保证了性能。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]},{"title":"mongoose入门介绍","slug":"test","date":"2018-09-05T08:14:16.000Z","updated":"2019-08-08T08:55:38.593Z","comments":true,"path":"2018/09/05/test/","link":"","permalink":"https://herrludwig.github.io/2018/09/05/test/","excerpt":"","text":"一、mongoose介绍Mongoose 是在 Node.js 异步环境下对 MongoDB 进行便捷操作的对象模型工具。Mongoose 有两个特点： 通过关系型数据库的思想来设计非关系型数据库 简化对 MongoDB 的操作 二、安装及使用1. 安装1npm i mongoose --save 2. 引入并连接12const mongoose = require(&apos;mongoose&apos;);mongoose.connect(&apos;mongodb://localhost/test&apos;,&#123; useNewUrlParser: true &#125;); 3. 定义SchemaSchema为数据库对象的集合。Schema 是 Mongoose 里用到的一种数据模式，可以理解为“表”结构的定义；每个 Schema 会映射到 Mongodb 中的一个 collection。 12345678var UserSchema=mongoose.Schema(&#123; // 注意：字段名称必须和collection保持一致 name: String, age:Number, status:&#123; type:Number, default:1 &#125;&#125;) 4. 创建数据模型modelmodel 是由 Schema 生成的模型，可以对数据库进行操作，而Schema不能对数据库进行操作。mongoose.mode 里面可以传入两个或三个参数。 1mongoose.model（参数1：&apos;模型名称&apos;（首字母大写），参数2：XXSchema，参数3：集合名称） 如果传入2个参数的话，这个模型会和模型名称相同的复数的集合建立连接。如通过下面方法创建模型，那么这个模型将会操作 users 这个集合。 1var User=mongoose.model(&apos;User&apos;, UserSchema) 如果传入3个参数的话，模型默认操作第三个参数定义的集合名称。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://herrludwig.github.io/categories/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://herrludwig.github.io/tags/数据库/"}]}]}